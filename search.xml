<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cesium - 加载高德实时栅格路况图层</title>
      <link href="/2020/01-cesium-traffic-amap/"/>
      <url>/2020/01-cesium-traffic-amap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有需要在Cesium中加载道路拥堵情况，像高德百度的思路应该是通过实时采集的数据来制成道路拥堵图，然后切片，根据一定时间频率更新切片。搜了一下网上有ol接入高德地图的例子，观察了一下ol中加载高度路况的例子中请求，发现是请求是<code>x={x}&amp;y={y}&amp;z={z}</code>这种表达的，说明在Cesium中是可以直接加载的，用<code>UrlTemplateImageryProvider</code>，用<code>vue-cesium</code>的话就是<code>vc-provider-imagery-urltemplate</code>组件，下面讲一下用<code>vue-cesium</code>加载高德路况图层的方法。</p><a id="more"></a><h2 id="高德加载路况图层"><a href="#高德加载路况图层" class="headerlink" title="高德加载路况图层"></a>高德加载路况图层</h2><p>废话不多说，直接上代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;vc-viewer&gt;</span><br><span class="line">    &lt;!-- 高德底图图层 --&gt;</span><br><span class="line">      &lt;vc-layer-imagery&gt;</span><br><span class="line">      &lt;vc-provider-imagery-urltemplate :url&#x3D;&quot;urlBase&quot;&gt;&lt;&#x2F;vc-provider-imagery-urltemplate&gt;</span><br><span class="line">    &lt;&#x2F;vc-layer-imagery&gt;</span><br><span class="line">    &lt;!-- 高德路况图层 --&gt;</span><br><span class="line">    &lt;vc-layer-imagery&gt;</span><br><span class="line">      &lt;vc-provider-imagery-urltemplate :minimumLevel&#x3D;&quot;6&quot; :maximumLevel&#x3D;&quot;20&quot; :url&#x3D;&quot;urlRoad&quot;&gt;&lt;&#x2F;vc-provider-imagery-urltemplate&gt;</span><br><span class="line">    &lt;&#x2F;vc-layer-imagery&gt;</span><br><span class="line">  &lt;&#x2F;vc-viewer&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      urlRoad: &#39;https:&#x2F;&#x2F;tm.amap.com&#x2F;trafficengine&#x2F;mapabc&#x2F;traffictile?v&#x3D;1.0&amp;x&#x3D;&#123;x&#125;&amp;y&#x3D;&#123;y&#125;&amp;z&#x3D;&#123;z&#125;&amp;t&#x3D;1595299423352&#39;,</span><br><span class="line">      urlBase: &#39;https:&#x2F;&#x2F;webst01.is.autonavi.com&#x2F;appmaptile?style&#x3D;7&amp;x&#x3D;&#123;x&#125;&amp;y&#x3D;&#123;y&#125;&amp;z&#x3D;&#123;z&#125;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20200722085924.png" alt="效果图"></p><p>问题探讨</p><ul><li>实测cesium加载高德路况图层的时候最小层级是6，最大层级是20。另外还需要做跨域处理。</li><li>内网环境下，自己通过数据生成路况切片，还是个难题。</li></ul><p>最后附上高德官方例子</p><ul><li><a href="https://lbs.amap.com/api/javascript-api/example/thirdlayer/functile/" target="_blank" rel="noopener">加载栅格图</a></li></ul><p>The End!</p>]]></content>
      
      
      <categories>
          
          <category> Cesium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cesium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cesium - 距离、面积、高度量算</title>
      <link href="/2019/01-cesium-measure-tool/"/>
      <url>/2019/01-cesium-measure-tool/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期工作之余都在继续开发个人开源项目 <strong><a href="https://github.com/zouyaoji/vue-cesium" target="_blank" rel="noopener">vue-cesium</a></strong> ，在最近学习中发现自己之前码的代码不太优雅，不太精炼，所以花不少时间重构了第二版，获益匪浅。其中就发现之前做的量算功能结果不太合适，尤其是面积量算，看网上很少有正确的思路，所以在这儿记录核心代码，详细请移步 GitHub 查看，欢迎提 Issue、PR，顺便小手点个 Star 也可以。<code>vue-cesium</code> 在 2.0.3 版本将会优化量算组件，在线体验地址: <a href="https://zouyaoji.top/vue-cesium/#/zh/tool/vc-measuring">https://zouyaoji.top/vue-cesium/#/zh/tool/vc-measuring</a></p><a id="more"></a><h2 id="距离量算"><a href="#距离量算" class="headerlink" title="距离量算"></a>距离量算</h2><p>之前用的是 <code>Cartesian3.distance</code> 计算两点之间的距离，但这是不合适的，原因是 <code>Cartesian3.distance</code> 计算的是两点之间的直线距离，忽略了地球曲率，不太合理，应该改为量算测地距离(GeodesicDistance)。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入坐标数组计算距离。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array.Cartesian3&#125;</span> </span>positions 传入的坐标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span> </span>返回长度数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getDistance (positions) &#123;</span><br><span class="line">  <span class="comment">// const &#123; Cartesian3 &#125; = Cesium</span></span><br><span class="line">  <span class="keyword">let</span> distance = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; positions.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Cartesian3.distance 计算的是两点之间的直线距离，忽略了地球曲率，不太合理。</span></span><br><span class="line">    <span class="comment">// let s = Cartesian3.distance(positions[i], positions[i + 1])</span></span><br><span class="line">    <span class="comment">// 2.0.3 版本改为测地距离（GeodesicDistance）。</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="keyword">this</span>.getGeodesicDistance(positions[i], positions[i + <span class="number">1</span>])</span><br><span class="line">    distance = distance + s</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> distance</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两点之间的测地距离。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Cartesian3&#125;</span> </span>pointOne 第一个坐标点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Cartesian3&#125;</span> </span>pointTwo 第二个坐标点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span> </span>返回两点之间的测地距离。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getGeodesicDistance (pointOne, pointTwo) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; Ellipsoid, EllipsoidGeodesic &#125; = Cesium</span><br><span class="line">  <span class="keyword">const</span> pickedPointCartographic = Ellipsoid.WGS84.cartesianToCartographic(</span><br><span class="line">    pointOne</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> lastPointCartographic = Ellipsoid.WGS84.cartesianToCartographic(</span><br><span class="line">    pointTwo</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> geodesic = <span class="keyword">new</span> EllipsoidGeodesic(</span><br><span class="line">    pickedPointCartographic,</span><br><span class="line">    lastPointCartographic</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> geodesic.surfaceDistance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面积量算"><a href="#面积量算" class="headerlink" title="面积量算"></a>面积量算</h2><p>之前用的是将笛卡尔坐标数组转经纬度然后构造 turf 的多边形对象，用 <code>@turf/area</code> 计算多边形面积，这很好，本身并没有问题，但美中不足的是这个实际上计算的是三维面投影到二维表名的投影面积，没有考虑高度。近期我才 GET 到正确的解决思路是将多边形分解成多个三角形，这点 Cesium 直接轻松做到，然后用<a href="https://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F#1" target="_blank" rel="noopener">海伦公式</a>计算面积。话不多说，上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 <span class="doctag">@turf</span>/area 获取传入坐标的构成的多边形的面积。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array.Cartesian&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span> </span>返回面积数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getProjectedArea (positions) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; Cartographic, <span class="attr">Math</span>: CesiumMath &#125; = Cesium</span><br><span class="line">  <span class="keyword">let</span> array = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = positions.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> cartographic = Cartographic.fromCartesian(positions[i])</span><br><span class="line">    <span class="keyword">let</span> longitude = CesiumMath.toDegrees(cartographic.longitude).toFixed(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">let</span> latitude = CesiumMath.toDegrees(cartographic.latitude).toFixed(<span class="number">6</span>)</span><br><span class="line">    array.push(&#123; <span class="attr">x</span>: longitude, <span class="attr">y</span>: latitude &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arrs = []</span><br><span class="line">  <span class="keyword">let</span> tems = []</span><br><span class="line">  arrs.push(tems)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">    tems.push([array[i].x, array[i].y])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> polygons = &#123;</span><br><span class="line">    type: <span class="string">'FeatureCollection'</span>,</span><br><span class="line">    features: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">'Feature'</span>,</span><br><span class="line">        properties: &#123;&#125;,</span><br><span class="line">        geometry: &#123;</span><br><span class="line">          type: <span class="string">'Polygon'</span>,</span><br><span class="line">          coordinates: arrs</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">'Feature'</span>,</span><br><span class="line">        properties: &#123;&#125;,</span><br><span class="line">        geometry: &#123;</span><br><span class="line">          type: <span class="string">'Polygon'</span>,</span><br><span class="line">          coordinates: [[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area(polygons)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用海伦公式获取传入坐标的构成的多边形的面积。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array.Cartesian&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span> </span>返回面积数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getSurfaceArea (positions) &#123;</span><br><span class="line">  <span class="keyword">if</span> (positions.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; Cartesian3, EllipsoidTangentPlane, Ellipsoid, <span class="attr">Math</span>: CesiumMath, PolygonGeometryLibrary, PolygonHierarchy, VertexFormat &#125; = Cesium</span><br><span class="line">  <span class="keyword">const</span> perPositionHeight = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 获取组成多边形的三角形。</span></span><br><span class="line">  <span class="keyword">const</span> tangentPlane = EllipsoidTangentPlane.fromPoints(</span><br><span class="line">    positions,</span><br><span class="line">    Ellipsoid.WGS84</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> polygons = PolygonGeometryLibrary.polygonsFromHierarchy(</span><br><span class="line">    <span class="keyword">new</span> PolygonHierarchy(positions),</span><br><span class="line">    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),</span><br><span class="line">    !perPositionHeight,</span><br><span class="line">    Ellipsoid.WGS84</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> geom = PolygonGeometryLibrary.createGeometryFromPositions(</span><br><span class="line">    Ellipsoid.WGS84,</span><br><span class="line">    polygons.polygons[<span class="number">0</span>],</span><br><span class="line">    CesiumMath.RADIANS_PER_DEGREE,</span><br><span class="line">    perPositionHeight,</span><br><span class="line">    VertexFormat.POSITION_ONLY</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (geom.indices.length % <span class="number">3</span> !== <span class="number">0</span> || geom.attributes.position.values.length % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是三角形，无法计算。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> coords = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; geom.attributes.position.values.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">    coords.push(</span><br><span class="line">      <span class="keyword">new</span> Cartesian3(</span><br><span class="line">        geom.attributes.position.values[i],</span><br><span class="line">        geom.attributes.position.values[i + <span class="number">1</span>],</span><br><span class="line">        geom.attributes.position.values[i + <span class="number">2</span>]</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; geom.indices.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ind1 = geom.indices[i]</span><br><span class="line">    <span class="keyword">const</span> ind2 = geom.indices[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> ind3 = geom.indices[i + <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> a = Cartesian3.distance(coords[ind1], coords[ind2])</span><br><span class="line">    <span class="keyword">const</span> b = Cartesian3.distance(coords[ind2], coords[ind3])</span><br><span class="line">    <span class="keyword">const</span> c = Cartesian3.distance(coords[ind3], coords[ind1])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 海伦公式</span></span><br><span class="line">    <span class="keyword">const</span> s = (a + b + c) / <span class="number">2.0</span></span><br><span class="line">    area += <span class="built_in">Math</span>.sqrt(s * (s - a) * (s - b) * (s - c))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三角测量"><a href="#三角测量" class="headerlink" title="三角测量"></a>三角测量</h3><p>三角测量的代码没啥说的，直接移步 Github 查看吧。</p><p>The End!</p>]]></content>
      
      
      <categories>
          
          <category> Cesium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cesium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全栈开发学习：Vue2+Koa2 开发前后端分离项目一（登陆验证）</title>
      <link href="/2018/06-Vue2+Koa2-1/"/>
      <url>/2018/06-Vue2+Koa2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录自己从零开始构建一个前后端分离的项目。之前学习了比较流行的 Vue，但仅会做一些展示页面，如处女作<a href="https://www.songluck.com/" target="_blank" rel="noopener">成都送福物流</a>。现在想做一些物流订单管理的功能，那自然离不开后台服务了。学习之路永无止境，通过一段时间的网络搜索学习，我了解到像我这样前端基础一般，后端服务基础为零的选手，后端服务就用 NodeJS 比较好上手一点，而且前端 Vue 项目也接触不少 NodeJS。本次我打算前端采用 Vue 全家桶和 Quasar Framework 完成，后端用 Koa2 和 MySQL。</p><p>本篇是登录验证的学习总结，主要是后端基础部分搭建，会用到<a href="https://jwt.io/" target="_blank" rel="noopener">JSON-WEB-TOKEN</a>。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h3><h4 id="1、安装-MySQL"><a href="#1、安装-MySQL" class="headerlink" title="1、安装 MySQL"></a>1、安装 MySQL</h4><p>到<a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">MySQL 官网</a>下载对应操作系统的 MySQL 并安装。</p><h4 id="2、表设计"><a href="#2、表设计" class="headerlink" title="2、表设计"></a>2、表设计</h4><p>用户表设计看了文章<a href="https://www.cnblogs.com/jiqing9006/p/5937733.html" target="_blank" rel="noopener">浅谈数据库用户表结构设计，第三方登录</a>觉得比较合理，用了2张表，users存用户基本信息，user_auths存用户授权信息。</p><h3 id="二、构建项目"><a href="#二、构建项目" class="headerlink" title="二、构建项目"></a>二、构建项目</h3><h3 id="1、用koa脚手架初始化一个项目"><a href="#1、用koa脚手架初始化一个项目" class="headerlink" title="1、用koa脚手架初始化一个项目"></a>1、用koa脚手架初始化一个项目</h3><p>（1）全局安装 koa 脚手架模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-generator -g</span><br></pre></td></tr></table></figure><p>（2）用 koa 生成初始项目结构并下载依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa koa-test &amp;&amp; cd koa-test &amp;&amp; npm install</span><br></pre></td></tr></table></figure><p>（3）运行</p><p>执行以下命令，访问<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>看见“Hello World Koa!”说明项目初始化成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="2、安装要用到的依赖并调整项目结构"><a href="#2、安装要用到的依赖并调整项目结构" class="headerlink" title="2、安装要用到的依赖并调整项目结构"></a>2、安装要用到的依赖并调整项目结构</h3><p>会用到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save koa-jwt mysql2 sequelize</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Koa </tag>
            
            <tag> Quasar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让我们对地形动动手脚</title>
      <link href="/2018/04-let-us-modify-terrain/"/>
      <url>/2018/04-let-us-modify-terrain/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与地理信息系统(GIS, Geographic information system)相关的，如建筑、规划、景观设计、防灾等领域的模型，地形模型是重中之重。因为一个项目模型中中，地形数据的存在不仅让模型表达的更真实，还能结合地形做一些基于地形的GIS分析。</p><p>地形一般有两种，<code>Grid</code>(规则格网) 和 <code>TIN</code>(不规则三角网)，他们是表示数字高程模型的两种方法。</p><p>今天让我们对地形动动手脚，主要介绍一下<a href="http://www.supermap.com.cn/" target="_blank" rel="noopener">SuperMap</a>平台TIN地形操作。</p><a id="more"></a><h2 id="DEM-地形简介"><a href="#DEM-地形简介" class="headerlink" title="DEM 地形简介"></a>DEM 地形简介</h2><p>传统上常用 <code>DEM</code> 表达地形特征。<code>DEM</code>（Digital Elevation Model，数字高程模型）主要用于描述一个区域的地貌形态的空间分布情况，同时通过高程测量点（或从等高线中进行采样提取高程点）进行内插或模拟计算获得。 <a href="http://support.supermap.com.cn/DownloadCenter/ProductPlatform.aspx" target="_blank" rel="noopener">SuperMap</a> 提供的地形构建功能通过点或者线数据插值生成 DEM 数据，结果为一个栅格数据集。</p><p>超图平台提供了三种方式实现地形的构建：</p><ol><li>通过点数据（高程点）生成 DEM，实现思路与插值算法相似。</li><li>通过线数据（等高线）生成 DEM，可以强化一些地形特征，如山脊线、山谷线等。</li><li>通过点数据（高程点）和线数据（等高线）联合构建，由于加入了特征点高程信息，如山顶、洼地、山脊点、山谷点等，此种方式生成的 DEM 更具有立体感。</li></ol><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp3zbmo10hj21hk0t4hdt" alt="SuperMap 平台的二维栅格地形"></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp43vvv8faj21hk0t44a8" alt="SuperMap 平台的三维栅格地形"></p><p>上两幅图是 SuperMap 平台范例数据 <code>BeijingDEM</code> 地形二维和三维的展示，整体效果感觉不错的，这种实际上是栅格（<code>Grid</code>）地形，是一种规则的格网。<strong>GRID在计算上比较简单，适用于采样点少的情况，但在地形平坦的地方存在大量数据冗余，不改变其格网大小也难以表达复杂地形。</strong></p><h2 id="TIN-地形"><a href="#TIN-地形" class="headerlink" title="TIN 地形"></a>TIN 地形</h2><p><code>TIN</code>（Triangulated Irregular Network） 指不规则三角网，<strong><code>TIN</code> 可以减少数据冗余，表达经度更高，同时在计算效率方面比较有优势，在地理信息系统中有广泛应用。</strong></p><h3 id="生成-TIN-地形"><a href="#生成-TIN-地形" class="headerlink" title="生成 TIN 地形"></a>生成 TIN 地形</h3><h4 id="桌面生成"><a href="#桌面生成" class="headerlink" title="桌面生成"></a>桌面生成</h4><ol><li><p>第一步 工作空间管理器中，右击 <code>DEM25</code> 栅格数据集，选则<code>生成场景缓存...</code></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp45zxjcqxj20980fft9h" alt="生成场景缓存入口"></p></li><li><p>第二步 参数设置，详见截图：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46cy14p1j20hz0jq0tl" alt="生成场景缓存参数设置"></p></li><li><p>第三步 生成场景缓存，生成过程和截图分别如图：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46ep5isej20hz0jqq3o" alt="生成场景缓存中"><br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46fork8fj20li09s0t7" alt="TIN缓存目录结构"></p></li><li><p>第四步 效果展示，左侧是 <code>TIN</code> 地形，右侧是 <code>Grid</code> 地形：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46k14331j21hk0t4wvn" alt="效果对比"></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp48x342duj21hk0t47wi" alt="效果对比2"></p></li></ol><h3 id="TIN-地形数据处理"><a href="#TIN-地形数据处理" class="headerlink" title="TIN 地形数据处理"></a>TIN 地形数据处理</h3><p><code>TIN</code> 地形数据处理主要包括：合并 TIN 缓存、TIN 叠加海洋、TIN 生成大文件、TIN 缓存提取点数据等操作。</p><h4 id="合并-TIN缓存"><a href="#合并-TIN缓存" class="headerlink" title="合并 TIN缓存"></a>合并 TIN缓存</h4><p>目前三维场景只允许加载一个Tin缓存数据（*.sct），若想加载多份Tin缓存数据，则需将多份数据合并为一个Tin缓存。合并Tin缓存功能能够将两个不同分辨率（块大小）的Tin缓存数据合并，最终生成一个Tin缓存文件。</p><p>在“数据”选项卡的“三维数据”组中，单击“合并Tin缓存”按钮，弹出“Tin缓存合并”对话框，如下图所示。</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46qpmpbwj20ch064q2u" alt="TIN缓存合并对话框"></p><h4 id="TIN-叠加海洋"><a href="#TIN-叠加海洋" class="headerlink" title="TIN 叠加海洋"></a>TIN 叠加海洋</h4><p>根据精确的海岸线范围生成带海洋边界的Tin缓存，在TIN地形范围内指定矢量范围作为海洋效果的叠加区域。用矢量面构建地图，黑色代表陆地，白色代表海洋，然后生成全球剖分的三维缓存。三维缓存范围要和Tin地形的范围保持一致。</p><p>在“数据”选项卡&gt;“三维数据”组中，单击“Tin地形数据”&gt;“TIN叠加海洋”按钮，并弹出“Tin叠加海洋”对话框，选则叠加的矢量面，设置结果保存目录，点确定。成功之后加载到场景，且需要勾上场景属性的“海洋水体”设置。</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp46z759m7j20jm05hdgk" alt="TIN叠加海洋入口"></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp470fa6z1j20as0ak0su" alt="TIN叠加海洋"></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp47acu03wj21hk0t47wh" alt="TIN叠加海洋结果"></p><h4 id="TIN-生成混合大文件"><a href="#TIN-生成混合大文件" class="headerlink" title="TIN 生成混合大文件"></a>TIN 生成混合大文件</h4><p>TIN地形缓存数据分块存储在多个文件夹中，每个文件夹下又存有若干TIN缓存文件，场景需通过读取这些碎文件的方式实现加载浏览整个TIN地形模型。为了进一步提升TIN地形模型的加载浏览效率，程序提供“TIN生成混合大文件”功能，可以将存储在文件夹下的诸多碎文件生成为一个*.cf格式的TIN地形缓存混合大文件。</p><p>在“数据”选项卡的“三维数据”组中，单击“TIN地形”下拉按钮，在弹出的下拉菜单中选择“TIN生成混合大文件”，弹出“TIN生成混合大文件”对话框，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp48ejdogvj20aj073wej" alt="TIN生成混合大文件"></p><p>生成成功后，在目标文件夹下生成了一份与源配置文件同名的配置文件(<em>.SCT)，每啊个文件夹下都生成一个以设定的缓存名称命名的紧凑缓存文件(</em>.cf)，示例结果如下图：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp48ezjn89j207e0c4t8n" alt="TIN生成混合大文件结果"></p><h4 id="TIN-缓存提取点数据"><a href="#TIN-缓存提取点数据" class="headerlink" title="TIN 缓存提取点数据"></a>TIN 缓存提取点数据</h4><p>“TIN提取点数据”是获取点在指定TIN地形上的高程值，支持二维点和三维点。</p><p>在“数据”选项卡的“三维数据”组中，单击“TIN地形”下拉按钮，在弹出的下拉菜单中选择“提取点数据”，弹出“TIN缓存提取点”对话框，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp48kjf8hkj209h0ajmxd" alt="提取点数据"></p><ul><li>对于二维点，执行另存为操作，是将二维点转为三维点。</li><li>暂不支持TIN混合文件上的点数据提取。</li></ul><h3 id="TIN-地形操作"><a href="#TIN-地形操作" class="headerlink" title="TIN 地形操作"></a>TIN 地形操作</h3><p><code>TIN</code> 地形操作主要包括：裁剪、挖洞、镶嵌、布尔运算、地形修改、叠加海洋、拉伸闭合体等操作。</p><ul><li><p>地形操作需要在场景中加载 <code>TIN</code> 地形缓存，操作示范如下：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp491kh02cj209c05a3yi" alt="添加地形缓存"></p></li><li><p>历史记录：在SuperMap iDesktop软件上对TIN地形操作后，能保留历史记录。点击“TIN裁剪”对话框中的“撤回”按钮，能回滚到离当前时间节点最近一次操作的历史记录处。</p></li></ul><h4 id="Tin-地形裁剪"><a href="#Tin-地形裁剪" class="headerlink" title="Tin 地形裁剪"></a>Tin 地形裁剪</h4><p>为了配合DEM 生成TIN地形缓存的使用，对TIN地形缓存数据进行多种形式的裁剪操作，更好的利用数据。</p><ol><li>在场景中加载TIN地形缓存（文件格式为*.sct）。在图层管理器中，鼠标右键单击“地形图层”，选择菜单列表中添加地形缓存。</li><li>在图层管理器中选中地形缓存图层，右键单击“快速定位到本图层”，在场景窗口按住鼠标滚轮将相机调整至便于裁剪模型的视角。</li><li><p>在“对象操作”选项卡上的“TIN地形操作”组中，单击“裁剪”项，弹出“TIN裁剪”对话框，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp492t518tj20830f73yp" alt="TIN裁剪对设置面板"></p><ul><li>参数设置：单击“裁剪方式”组合框的下拉箭头，选择“保留区域内”或“保留区域外”一种裁剪方式。保留区域内裁剪方式是裁剪获取封闭区域内的TIN地形缓存，保留区域外裁剪方式是裁剪获取封闭区域外的TIN地形缓存。单击“约束边界”组合框的下拉箭头，选择“软约束”或“硬约束”一种约束方式。软约束是裁剪结果边界高程值和原来一致，保持不变；硬约束是裁剪结果边界高程和裁剪面边界高程值一致。</li></ul></li><li><p>裁剪效果：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57qmysf6j21hc0u0wyf" alt="裁剪效果"></p></li></ol><h4 id="Tin-地形挖洞"><a href="#Tin-地形挖洞" class="headerlink" title="Tin 地形挖洞"></a>Tin 地形挖洞</h4><p>在 TIN 地形上镂空一个洞，三维模型叠加显示，形成模型与地形匹配的效果。</p><ol><li>在场景中加载TIN地形缓存（文件格式为*.sct）。在图层管理器中，鼠标右键单击“地形图层”，选择菜单列表中添加地形缓存。</li><li><p>在“对象操作”选项卡上的“TIN地形操作”组中，单击“挖洞”项，弹出“TIN挖洞”对话框，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp4amoay0oj20870fbdg1" alt="TIN挖洞"></p><ul><li><p>挖洞面确定：单选“选择面”或“绘制面”确定挖洞面类型。当选择“绘制面”，工具栏提供了“矩形”、“多边形”和“导入”三种方法进行镶嵌面的绘制，</p><ul><li>矩形挖洞：鼠标左键单击“矩形挖洞”按钮，在场景中Tin地形上绘制需要挖洞的矩形区域。</li><li>多边形挖洞：单击“多边形挖洞”按钮，在场景中Tin地形上绘制需要挖洞的多边形区域。</li><li>选中对象区域挖洞：选择单个或多个二、三维面对象进行挖洞。SuperMap建议:先选择面对象，再单击“选中对象区域挖洞”按钮。</li><li>导入按钮单击后弹出的对话框，导入面。</li></ul></li></ul></li><li><p>效果图：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57unxpl1j20z80howti" alt="挖洞效果图"></p></li></ol><h4 id="Tin-地形镶嵌"><a href="#Tin-地形镶嵌" class="headerlink" title="Tin 地形镶嵌"></a>Tin 地形镶嵌</h4><p>对已有的地形数据与模型之间不能严格的匹配上，存在公路、护坡被地形压盖或隧道洞口处被地形遮挡等问题。可通过TIN地形-镶嵌功能，利用模型的边界面与TIN地形进行镶嵌，使地形与模型能够很好的贴合。</p><ol><li>利用“对象操作”选项卡&gt;“模型操作”组中数据提取下的“提取边界”功能，提取被地形压盖或遮挡的模型边界面。</li><li><p>将获取到的面数据集添加到场景中，选择与地形进行镶嵌的面对象有多种方法，以下列举一种对于面对象较多的情况： 在“对象操作”选项卡上的“TIN地形操作”组中，单击“镶嵌”项，弹出“TIN镶嵌”对话框。</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp4arrf8qwj20880f8t8v" alt="TIN镶嵌"></p><ul><li><p>镶嵌面确定：单选“选择面”或“绘制面”确定镶嵌面类型。当选择“绘制面”，工具栏提供了“矩形”、“多边形”和“导入”三种方法进行镶嵌面的绘制，其中导入按钮单击后弹出的对话框，如下图所示。</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57jx1xaxj207w03st8k" alt="导入镶嵌面"></p></li></ul></li><li><p>镶嵌效果</p><ul><li>镶嵌前：<br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57kjnzpxj20y70hygnf" alt="镶嵌前"></li><li>镶嵌后：<br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57l2433lj20vb0h9aco" alt="镶嵌后"></li></ul></li></ol><h4 id="Tin-布尔运算"><a href="#Tin-布尔运算" class="headerlink" title="Tin 布尔运算"></a>Tin 布尔运算</h4><p>“布尔运算”功能是在场景中将TIN地形与模型数据进行求差运算或合并运算，得到新的TIN地形数据。目前只支持单模型的布尔运算。</p><ol><li><p>加载数据源。数据源需要包含模型数据集和TIN地形数据。添加到场景中的示范效果如下：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp5djapc2dj20fm0b6am1" alt="TIN地形和模型数据示范效果"></p></li><li><p>打开布尔运算窗口。在“对象操作”选项卡上的“TIN地形操作”组中，单击“布尔运算”按钮，弹出布尔运算对话框如下：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57f0xhkaj209b09fdft" alt="布尔运算"></p></li><li><p>点击“确定“进行布尔运算。示例数据求差的运算结果如下：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp5dlgrk3gj20gj0aswos" alt="布尔运算结果"></p></li></ol><h4 id="Tin-拉伸闭合体"><a href="#Tin-拉伸闭合体" class="headerlink" title="Tin 拉伸闭合体"></a>Tin 拉伸闭合体</h4><p>“TIN地形拉伸闭合体”功能是对TIN地形向上拉伸至指定高程处,形成一个闭合体。该方法可以用于3D打印的实体模型构建。</p><ol><li>添加TIN地形缓存数据。</li><li><p>在“对象操作”选项卡上的“TIN地形操作”组中，单击“拉伸闭合体”按钮，弹出“拉伸闭合体”对话框，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp56pw02ydj20880ibq3a" alt="拉伸闭合体设置"></p></li><li><p>拉伸范围设置</p><ul><li>默认勾选“自定义范围”，自行设置拉伸闭合体范围，否则使用TIN地形的默认范围。</li><li>拉伸范围自定义：拉伸范围可以通过“选择面”或“绘制面”进行确定，其中绘制面提供矩形、多边形、导入和移除功能。</li></ul></li><li><p>拉伸对象的参数设置</p><ul><li>裁剪方式：包括保留区域内和保留区域外，默认为保留区域内。</li><li>约束边界：包括硬约束和软约束，默认为软约束。</li><li>拉伸高度设置：输入拉伸高度值或通过上下箭头调整拉伸高度值。</li></ul></li><li>结果数据的存放<ul><li>数据源：自动生成“临时数据”数据源。</li><li>数据集名称：输入字符串作为结果数据集的名称。</li></ul></li><li>效果图</li></ol><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp574omplqj21hc0u0aul" alt="效果图"></p><h4 id="Tin-地形修改"><a href="#Tin-地形修改" class="headerlink" title="Tin 地形修改"></a>Tin 地形修改</h4><p>“地形修改”功能实现对当前TIN地形的实时修改。该功能可绘制或导入多边形作为修改区域，修改后的地形通过调整高程值实时修改高度，同时该功能提供了对修改区域的管理,包括删除修改区域、导入修改区域和导出修改区域。</p><ol><li>加载需要修改的地形数据。</li><li>打开TIN地形修改功能。在“对象操作”选项卡上的“TIN地形操作”组中，单击“地形修改”按钮，窗体右侧弹出TIN地形修改对话框。</li><li>修改区域设置。修改区域操作按钮依次为添加修改区域、删除修改区域、导入修改区域、保存修改区域。<ul><li>添加修改区域：点击添加按钮，直接在TIN地形上进行绘制多边形区域，作为修改区域。</li><li>删除修改区域：删除选中的修改区域，同时取消了TIN地形修改操作。</li><li>导入修改区域：导入已经存在的多边形区域作为修改区域，如果没有现有多边形，默认进行多边形构建。</li><li>保存修改区域：保存进行TIN地形的修改区域。</li></ul></li><li><p>修改区域设置成功后自动进行TIN地形修改。TIN地形修改对话框内出现调整高程值的功能，通过上下按钮或手动输入高程值，实时修改TIN地形高程。修改TIN地形示范如下：</p><ul><li>地形修改参数：<br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57y8w5kgj208709qweg" alt="TIN地形修改"></li><li>地形修改效果：<br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp57z2c4m6j20jm07qjz7" alt="地形修改结果"></li></ul></li></ol><h3 id="TIN-地形分析"><a href="#TIN-地形分析" class="headerlink" title="TIN 地形分析"></a>TIN 地形分析</h3><p>TIN地形可以直接分层设色表达、坡度坡向分析、淹没分析。如果不支持，说明生成TIN缓存的时候没有勾选<code>带法线图</code>。</p><h4 id="TIN-地形分层设色"><a href="#TIN-地形分层设色" class="headerlink" title="TIN 地形分层设色"></a>TIN 地形分层设色</h4><p>分层设色是地图可视化的常用方式，它通过一定的颜色变化次序或色调深浅来表达和区别三维数据的不同属性。超图平台支持对倾斜摄影模型、点云三维切片缓存（osgb）数据、TIN地形设置颜色表、透明度、显示区域、最大/最小可见值等参数，实现模型的分层设色表达；另外支持三维栅格体数据设置颜色表。</p><ol><li>加载 TIN 地形缓存数据。</li><li><p>TIN 地形缓存图层右键，弹出菜单选择<code>属性</code>，弹出 TIN 地形面板，选择<code>分层设色</code>：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58hlmtngj206x09iaa5" alt="TIN地形图层属性"></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58jeii2ij20830gl74m" alt="TIN地形属性面板"></p><ul><li>显示区域：<ul><li>全部显示：默认为“全部显示”，即该图层模型全部参与分层设色表达。</li><li>区域显示：勾选此项后，将鼠标移至场景区域时变为编辑划线状态，可在模型上点击勾绘一个多边形区域，表示该多边形区域内的模型显示分层设色，区域外不显示分层设色。</li><li>选择区域：勾选此项后，激活“从数据集选择区域”的下拉框，选择当前工作空间打开的数据源、面/三维面数据集。当面数据集有多个多边形时，“SmID”数值最小的多边形显示分层设色，其他多边形不起作用。</li></ul></li><li>显示模式：提供了不显示、线填充、面填充、线面填充四种模式，点击右侧下拉框选择。<ul><li>不显示：默认不显示，即不进行分层设色表达。</li><li>线填充：采用显示等值线的方式进行分层设色表达。</li><li>面填充：采用面填充的方式进行分层设色表达。</li><li>线面填充：采用等值线与面填充的方式进行分层设色表达。</li></ul></li><li>线颜色：点击右侧颜色下拉框，选择等值线的颜色方案。</li><li>纹理颜色表：点击右侧颜色下拉框，选择填充面的颜色方案。</li><li>透明度：用来设置分析区域填充纹理的透明度，默认值为 0。</li><li>颜色表最小值：输入数字，用于设置纹理颜色表最左侧颜色所对应的高程/点云强度值，默认为模型高程/点云强度值的最小值。</li><li>颜色表最大值：输入数字，用于设置纹理颜色表最右侧颜色所对应的高程/点云强度值，默认为模型高程/点云强度值的最小值。</li><li>最小可见值：输入数字，用于设置参与分层设色表达的模型高程/点云强度值的最小值，默认为模型高程/点云强度值的最小值。小于该值的模型将不显示分层设色。</li><li>最大可见值：输入数字，用于设置参与分层设色表达的模型高程/点云强度值的最大值，默认为模型高程/点云强度值的最大值。大于该值的模型将不显示分层设色。<br>等值距：输入数字，用于设置等值线的间距，默认值为100米，表示每隔100米绘一条等值线。</li></ul></li><li><p>分层设色效果图：</p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58kdwin9j21hc0u0h6j" alt="分层设色效果图"></p></li></ol><h4 id="TIN-坡度坡向分析"><a href="#TIN-坡度坡向分析" class="headerlink" title="TIN 坡度坡向分析"></a>TIN 坡度坡向分析</h4><p>坡度和坡向是两个重要的地形特征因子，在地形表面分析中起到重要作用。其中，坡度是地表面上某一点的切面和水平面所成的夹角，坡度值越大，地势越陡峭；坡度值越小，地势越平坦。而坡度变化的方向称为坡向，指每个像元到其相邻像元方向上值的变化率最大的下坡方向，表示地表面某一位置斜坡方向变化的量度。</p><p>三维坡度坡向分析用于计算栅格数据集中各像元的坡度值，及像元坡度面的朝向。坡度用度数表示的分析结果的范围是0到90°；坡向计算的范围是0到360°，以正北方0°为开始，按顺时针移动，回到正北方以360°结束。</p><ol><li>加载 TIN 地形缓存数据。</li><li><p>TIN 地形缓存图层右键，弹出菜单选择<code>属性</code>，弹出 TIN 地形面板，选择<code>坡度坡向分析</code>。<br><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58zf51b0j20830dy74k" alt="坡度坡向分析面板"></p><ul><li>显示区域：<ul><li>全部显示：默认为“全部显示”，即该图层模型全部参与坡度坡向分析。</li><li>区域显示：勾选此项后，将鼠标移至场景区域时变为编辑划线状态，可在模型上点击勾绘一个多边形区域，表示该多边形区域内的模型显示坡度坡向，区域外不显示坡度坡向。</li><li>选择区域：勾选此项后，激活“从数据集选择区域”的下拉框，选择当前工作空间打开的数据源、面/三维面数据集。当面数据集有多个多边形时，“SmID”数值最小的多边形显示坡度坡向，其他多边形不起作用。</li></ul></li><li>显示模式：用来设置提取结果的显示模式，可设置的显示模式有坡度、坡向、坡度与坡向三种。</li><li>透明度：用来设置分析区域填充纹理的透明度，默认值为 0。</li><li>颜色表：同来设置分析区域的填充颜色，对应区域的坡度不同，则显示的颜色不同。</li><li>颜色表最小值：输入数字，用于设置纹理颜色表最左侧颜色所对应的高程/点云强度值，默认为模型高程/点云强度值的最小值。</li><li>颜色表最大值：输入数字，用于设置纹理颜色表最右侧颜色所对应的高程/点云强度值，默认为模型高程/点云强度值的最小值。</li><li>最小可见值：输入数字，用于设置参与分层设色表达的模型高程/点云强度值的最小值，默认为模型高程/点云强度值的最小值。小于该值的模型将不显示坡度坡向。</li><li>最大可见值：输入数字，用于设置参与分层设色表达的模型高程/点云强度值的最大值，默认为模型高程/点云强度值的最大值。大于该值的模型将不显示坡度坡向。</li><li>流动： 勾上坡向箭头会有流动效果。</li></ul></li><li><p>坡度坡向分析效果图：</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp59ctb30kj21hc0u0b29" alt="坡度坡向分析效果图"></p><h4 id="TIN-淹没分析"><a href="#TIN-淹没分析" class="headerlink" title="TIN 淹没分析"></a>TIN 淹没分析</h4><p>水淹分析是三维分析的一个重要方向，基于地形信息，它可以确定洪水淹没的范围、水深以及洪水在地理空间上的演进过程。目前，平台对倾斜摄影模型、TIN地形数据提供了展示淹没效果的功能，可实时模拟积水随时间变化的动态进展，从而快速判断内涝对交通、财产、人身可能造成的伤害。</p><ol><li>加载 TIN 地形缓存数据。</li><li><p>TIN 地形缓存图层右键，弹出菜单选择<code>属性</code>，弹出 TIN 地形面板，选择<code>淹没分析</code></p><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58tzs7iij20860ee3yq" alt="淹没分析面板"></p><ul><li>水体颜色表：点击右侧颜色下拉框，选择水体的颜色方案。</li><li>透明度：点击右侧按钮弹出设置水体透明度的滑块，滑动滑块调节；也可直接输入0-100的数字。默认透明度为 0，表示水体完全不透明；随着数值增大，水体会变得越来越透明；最大值为 100，表示完全透明。</li><li>当前水位高程：直接输入数字或点击“增加”“减少”的按钮调节当前水文高程。</li><li>最大水位：输入数字表示水体淹没的最大高程。</li><li>最小高程：此参数为自动获取且不可更改，为当前图层的高程最小值。</li><li>最大高程：此参数为自动获取且不可更改，为当前图层的高程最大值。</li><li>总时间(s)：用于显示和设置水体从最小高程淹没到最大水位所需时间，单位为：秒。调整总时间，速度数值将发生变化。</li><li>速度(m/s)：用来显示和设置水体从最小高程淹没到最大水位的速度，单位为：m/s。调整速度，总时间将发生变化。</li><li>播放控件：通过“开始”、“暂停”或“停止播放”按钮控制水体淹没模型的状态。</li><li>循环播放：勾选该复选框后，在模拟水体淹没时，将重复执行播放操作，直到用户停止播放；若未选中该复选框，则在播放完毕后自动停止。</li></ul></li><li><p>效果截图：</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/7a5fa15ely1fp58w1wh4fj21hc0u04gq" alt="淹没分析效果"></p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地形建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript面向对象编程总结</title>
      <link href="/2018/03-javascript-oop/"/>
      <url>/2018/03-javascript-oop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端学习过程中，时常会看到apply、call以及prototype的例子，总是似懂非懂，模棱两可，有时候要半天才明白怎么回事，也不知道怎么应用到实际工作中。开贴总结学习一下，即便是以后忘记了再来阅读重拾一下，同时希望能帮助到有同样困惑的前端入门者。</p><p>要想彻底弄清楚<strong>proto</strong>和prototype、call和apply的存在，首先要搞明白JavaScript面向对象编程。</p><a id="more"></a><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p><p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p><p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p><p>（1）对象是单个实物的抽象。</p><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p>（2）对象是一个容器，封装了属性（property）和方法（method）。</p><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p><p>在JavaScript中，万物皆对象，面向对象编程的第一步，就是要生成对象。典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, My name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">18</span>)</span><br><span class="line">zhangsan.name <span class="comment">// "zhangsan"</span></span><br><span class="line">zhangsan.hello() <span class="comment">// "Hello, My name is zhangsan!"</span></span><br><span class="line">Person.prototype === zhangsan.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Person</code>是构造函数（constructor），通过<code>new</code>命令让构造函数<code>Person</code>生成一个实例对象，保存在变量<code>zhangsan</code>中。这可理解为我们简单抽象了一个人，他现在具有“名字”、“年龄”特征（属性），他会“问好”这个技能（方法）。构造函数的特点有2个：</p><ul><li>函数体内部使用了this关键字，代表了所要生成的对象实例。</li><li>生成对象的时候，必须使用new命令。</li></ul><p>新创建的<code>zhangsan</code>的原型链是</p><blockquote><p>zhangsan -&gt; Person.prototype -&gt; Object.prototype -&gt; null</p></blockquote><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象（通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性）。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性<strong>proto</strong>，可称为<strong>隐式原型</strong>，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p><p>方法这个特殊的对象，除了和其他对象一样有上述<strong>proto</strong>属性之外，还有自己特有的属性——原型属性（prototype）（<strong>显示原型</strong>），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p><p>面向对象编程很重要的一个特点是<code>继承</code>。<strong>A</strong>对象通过继承<strong>B</strong>对象，就能直接拥有B对象的所有属性和方法。大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype），JavaScript中所谓的继承关系不过是把一个对象的原型指向了另一个对象。</p><h4 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h4><p>作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<strong>proto</strong>依次查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">'person'</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, My name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = &#123;</span><br><span class="line">  name: <span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zhangsan.__proto__ = Person</span><br><span class="line">zhangsan.hello() <span class="comment">// Hello, My name is zhangsan!</span></span><br></pre></td></tr></table></figure><p>注意最后一行代码把zhangsan的原型指向了对象Person，看上去zhangsan仿佛是从Person继承下来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is flying...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zhangsan.__proto__ = Bird</span><br><span class="line">zhangsan.fly() <span class="comment">// zhangsan is flying...</span></span><br></pre></td></tr></table></figure><p>现在<code>zhangsan</code>已经无法<code>hello()</code>了，他已经变成了一只鸟，可以<code>fly()</code>。</p><p><code>请注意</code>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。ES5中有了对于这个内置属性标准的Get方法<code>Object.getPrototypeOf()</code>，Set方法<code>Object.setPrototypeOf()</code>，如<code>zhangsan.__proto__ = Bird</code>正确写法应该是<code>Object.setPrototypeOf(zhangsan, Bird)</code>。</p><h4 id="显式原型-amp-原型链"><a href="#显式原型-amp-原型链" class="headerlink" title="显式原型&amp;原型链"></a>显式原型&amp;原型链</h4><p>作用：用来实现基于原型的继承与属性的共享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Unnamed'</span></span><br><span class="line">  <span class="keyword">this</span>.age = age || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, My name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的原型链是</p><blockquote><p>new Person() -&gt; Person.prototype -&gt; Object.prototype -&gt; null</p></blockquote><p>现在，我们准备从<code>Person</code>继承得到一个新的对象<code>Chengxuyuan</code>，必须想办法把原型链修改为：</p><blockquote><p>new Person() -&gt; Chengxuyuan.prototype -&gt; Person.prototype -&gt; Object.prototype -&gt; null</p></blockquote><p>这样，原型链对了，继承关系就对了。换句话说，基于构造函数<code>Chengxuyuan</code>创建的对象不但能调用<code>Chengxuyuan.prototype</code>定义的方法，还可以调用<code>Person.prototype</code>定义的方法，就达到目的了。比较经典的做法是参考道格拉斯的代码，用一个空函数<code>F</code>来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Unnamed'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, My name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chengxuyuan</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, props.name)</span><br><span class="line">    <span class="keyword">this</span>.language = props.language</span><br><span class="line">    <span class="keyword">this</span>.work = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' can do '</span> + <span class="keyword">this</span>.language + <span class="string">' jobs'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = Parent.prototype</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F()</span><br><span class="line">  Child.prototype.constructor = Child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(Chengxuyuan, Person)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Chengxuyuan(&#123;</span><br><span class="line">  name:<span class="string">'zhangsan'</span>,</span><br><span class="line">  language: <span class="string">'JavaScript'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Chengxuyuan.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zhangsan.getName() <span class="comment">// "zhangsan"</span></span><br><span class="line">zhangsan.hello() <span class="comment">// "Hello, My name is zhangsan!"</span></span><br><span class="line">zhangsan.__proto__ === Chengxuyuan.prototype <span class="comment">// true</span></span><br><span class="line">zhangsan.__proto__.__proto__ === Person.prototype <span class="comment">// true</span></span><br><span class="line">zhangsan <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码，<code>Chengxuyuan</code>继承自<code>Person</code>，<code>Chengxuyuan</code>有了<code>Person</code>的属性和方法，<code>Chengxuyuan</code>还通过原型定义了新的方法。<code>instanceof</code>操作符可用于验证继承关系。</p><p>小结，JavaScript的原型继承实现方式就是：</p><ul><li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this。</li><li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成。</li><li>继续在新的构造函数的原型上定义新方法。</li></ul><h4 id="proto和prototype区别与联系"><a href="#proto和prototype区别与联系" class="headerlink" title="proto和prototype区别与联系"></a><strong>proto</strong>和prototype区别与联系</h4><p>经过从上面内容的学习，可以总结出二者区别：</p><ol><li>JavaScript里所有的对象都有<strong>proto</strong>属性（隐式原型），指向构造该对象的构造函数的原型。</li><li>只有函数function才具有prototype属性（显示原型）。这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</li></ol><p>二者联系：</p><ul><li>隐式原型指向创建这个对象的函数(constructor)的prototype。</li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>大多数面向对象编程的语言中，<code>this</code>关键字一般指向<code>this</code>所在的类。而JavaScript中，<code>this</code>关键字用在不同的场合，很可能表达的意思不一样。为了达到一些目的，有时候我们常常需要动态改变<code>this</code>的指向。</p><h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><p>在面向对象编程中，我们经常会像上面提到的例子中定义构造函数，会用<code>this</code>表示实例对象。<code>this</code>总会返回一个对象，一般是属性或者方法当前所在对象。</p><p>（1）全局环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>)</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p><p>（2）构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj(<span class="string">'Hello World!'</span>)</span><br><span class="line">o.p <span class="comment">// "Hello World!"</span></span><br></pre></td></tr></table></figure><p>上面代码中，构造函数中的<code>this</code>，指的是实例对象<code>o</code>。</p><p>（3）对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.describe() <span class="comment">// "姓名：张三"</span></span><br></pre></td></tr></table></figure><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.describe() <span class="comment">// "姓名：张三"</span></span><br><span class="line">B.describe() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p><p>只要函数被赋给另一个变量，this的指向就变了。</p><h4 id="call和apply的区别与联系"><a href="#call和apply的区别与联系" class="headerlink" title="call和apply的区别与联系"></a>call和apply的区别与联系</h4><p>通过前面的学习总结，我们知道<code>this</code>可以动态切换，为JavaScript创造了巨大的灵活性，但也使得编程的可读性变弱，难以理解，尤其是新手遇到这些，往往云里雾里。为了固定<code>this</code>的指向，JavaScript提供的<code>call</code>、<code>apply</code>等方法来固定/切换<code>this</code>的指向，这b便是<code>call</code>和<code>apply</code>存在的意义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype=&#123;</span><br><span class="line">  food: <span class="string">'fish'</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I love "</span>+<span class="keyword">this</span>.food)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blackCat = <span class="keyword">new</span> Cat()</span><br><span class="line">blackCat.say() <span class="comment">// I love fish</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们抽象了一个构造函数<code>Cat</code>，并且实例化出一个对象<code>blackCat</code>，具有<code>say</code>方法。但是如果我们有另外一个对象，我们不想对它重新定义say方法，那么我们可以通过<code>call</code>或<code>apply</code>用<code>blackCat</code>的<code>say</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whiteDog = &#123;<span class="attr">food</span>: <span class="string">'bone'</span>&#125;</span><br><span class="line">blackCat.say.call(whiteDog) <span class="comment">// I love bone</span></span><br><span class="line">blackCat.say.apply(whiteDog) <span class="comment">// I love bone</span></span><br></pre></td></tr></table></figure><p>上面代码中，可以看出 <code>call</code> 和 <code>apply</code> 是为了动态改变 <code>this</code> 而出现的，当一个 <code>object</code> 没有某个方法，但是其他的有，我们可以借助 <code>call</code> 或 <code>apply</code> 用其它对象的方法来操作。</p><ul><li>二者联系</li></ul><ol><li>二者的作用完全一样，均可改变JavaScript函数体内部<code>this</code>的指向。</li></ol><ul><li>二者区别</li></ul><ol><li>接受参数的方式不太一样。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Unnamed'</span></span><br><span class="line">  <span class="keyword">this</span>.age = age || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, My name is '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，可以通过<code>Person.call(this, name, age)</code> 或者 <code>Person.apply(this, [name, age])</code> 来调用。其中 <code>this</code> 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，<code>call</code> 需要把参数按顺序传递进去，而 <code>apply</code> 则是把参数放在数组里。</p><p>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 <code>call</code>，而不确定的时候，用 <code>apply</code>，然后把参数 <code>push</code> 进数组传递进去。当参数数量不确定时，函数内部也可以通过 <code>arguments</code> 这个数组来遍历所有的参数。</p><h4 id="打油诗"><a href="#打油诗" class="headerlink" title="打油诗"></a>打油诗</h4><p>猫吃鱼，狗吃肉，奥特曼打小怪兽。</p><p>有天狗想吃鱼了</p><p>猫.吃鱼.call(狗，鱼)</p><p>狗就吃到鱼了</p><p>猫成精了，想打怪兽</p><p>奥特曼.打小怪兽.call(猫，小怪兽)</p><p>就这样记住了。</p><p>The End!</p><p>欢迎批评指正！</p><p>参考资料：</p><p><a href="https://www.zhihu.com/question/20289071" target="_blank" rel="noopener">如何理解和熟练运用js中的call及apply？</a></p><p><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">js中<strong>proto</strong>和prototype的区别和关系？</a></p><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499763408e24c210985d34edcabbca944b4239e20000" target="_blank" rel="noopener">面向对象编程——廖雪峰</a></p><p><a href="http://javascript.ruanyifeng.com/#oop" target="_blank" rel="noopener">面向对象编程——阮一峰</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio Code 插件扩展推荐</title>
      <link href="/2018/02/01vscodeExts/"/>
      <url>/2018/02/01vscodeExts/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始自学前端的时候，在选择集成开发环境<a href="https://baike.baidu.com/item/集成开发环境" target="_blank" rel="noopener">IDE</a>（Integrated Development Environment）上也是花了一些功夫。先后体验了<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>、<a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a>、<a href="http://www.dcloud.io/" target="_blank" rel="noopener">HBuilder</a>和<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>。这几款工具各有所长，都使用过一段时间，最后我发现还是<strong>Visual Studio Code</strong>适合我。</p><p>Visual Studio Code刚出来的时候我就开始使用了，理由很简单：</p><ul><li>免费、开源、跨平台</li><li>微软出品、实力保证</li></ul><p>微软对于VSCode的定位如下图，位于编辑器与IDE之间，像是披着编辑器外衣的IDE，更像是披着IDE外衣的编辑器。<br><img src="https://i.loli.net/2019/12/20/vFZVHjukqTtoRnO.png" alt="VSCode定位"></p><p>在这儿我要赞一波Visual Studio Code，我认为它是最好用的开源文本编辑器，在保持其性能的基础上集成了很多IDE功能，可以说是微软良心出品，浓浓的微软情怀。<a href="https://www.zhihu.com/question/29984607" target="_blank" rel="noopener">点我看更多VSCode评价</a>。</p><p>Visual Studio Code之所以体验很好，其中很重要的一点原因是其不仅内置JavaScript、TypeScript和Node.js支持，还拥有丰富的插件（扩展）生态系统，可安装插件来支持C++、C#、Python、GO、PHP等其他语言。好了，其他就不多说了，觉得好与不好，各位可以体验之后自己评价一下。回到正题，分享一下我用到的VSCode扩展插件，主要是前端。</p><a id="more"></a><h2 id="文件图标-amp-颜色主题插件扩展"><a href="#文件图标-amp-颜色主题插件扩展" class="headerlink" title="文件图标&amp;颜色主题插件扩展"></a>文件图标&amp;颜色主题插件扩展</h2><p>“人靠衣装马靠鞍，狗配铃铛跑的欢”，VSCode也是，本身颜值一般，需要扩展主题改造，我这儿推荐几个我个人比较喜欢的文件图标和颜色主题插件，这个没啥好说的，直接上图。</p><h3 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme" target="_blank" rel="noopener">Material Icon Theme</a></h3><ul><li>Material风格</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220163440.png" alt="Material Icon Theme"></p><h3 id="vscode-icons"><a href="#vscode-icons" class="headerlink" title="vscode-icons"></a><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons" target="_blank" rel="noopener">vscode-icons</a></h3><ul><li>图标很全、风格不错</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo20rjx9rxg20m80gonpe.gif" alt="vscode-icons"></p><h3 id="VSCode-Greate-Icons"><a href="#VSCode-Greate-Icons" class="headerlink" title="VSCode Greate Icons"></a><a href="https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons" target="_blank" rel="noopener">VSCode Greate Icons</a></h3><ul><li>风格不错</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220163835.png" alt="VSCode Greate Icons"></p><h3 id="Atom-One-Dark-Theme"><a href="#Atom-One-Dark-Theme" class="headerlink" title="Atom One Dark Theme"></a><a href="https://marketplace.visualstudio.com/items?itemName=akamud.vscode-theme-onedark" target="_blank" rel="noopener">Atom One Dark Theme</a></h3><ul><li>One Dark Theme based on Atom</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220163851.png" alt="Atom One Dark Theme"></p><h3 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme" target="_blank" rel="noopener">One Dark Pro</a></h3><ul><li>Atom’s iconic One Dark theme for Visual Studio Code</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220163905.png" alt="One Dark Pro"></p><h3 id="One-Dark-Vivid"><a href="#One-Dark-Vivid" class="headerlink" title="One Dark Vivid"></a><a href="https://marketplace.visualstudio.com/items?itemName=kkozee.theme-one-dark-vivid" target="_blank" rel="noopener">One Dark Vivid</a></h3><ul><li>Atom’s One Dark Vivid Theme for VS Code</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164001.png" alt="One Dark Vivid"></p><h3 id="Monokai-Dark-Soda"><a href="#Monokai-Dark-Soda" class="headerlink" title="Monokai Dark Soda"></a><a href="https://marketplace.visualstudio.com/items?itemName=AdamCaviness.theme-monokai-dark-soda" target="_blank" rel="noopener">Monokai Dark Soda</a></h3><ul><li>A dark theme with bright colors</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164019.png" alt="Monokai Dark Soda"></p><h2 id="前端插件扩展"><a href="#前端插件扩展" class="headerlink" title="前端插件扩展"></a>前端插件扩展</h2><p>VSCode插件扩展很多，但常用的也就那么些个，可以按照自己的代码风格习惯+自己的技术栈安一些插件。比如我前端对NPM、GitHub、Vue接触比较多，我自然就关于方面的比较多，然后是代码规范的插件、代码美化的插件、调试的插件等。</p><h3 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener">Auto Close Tag</a></h3><ul><li>Automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text does. 为你的HTML标签自动添加结束标签。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo21yne23fg21400q2ajs.gif" alt="Auto Close Tag"></p><h3 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a></h3><ul><li>Auto rename paired HTML/XML tag. 自动帮你修改成对的HTML/XML标签。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo220e5wqsg21400q2q6y.gif" alt="Auto Rename Tag"></p><h3 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="noopener">Path Intellisense</a></h3><ul><li>Visual Studio Code plugin that autocompletes filenames. 自动帮你补全引用路径.</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo2249685sg20dc07i411.gif" alt="Path Intellisense"></p><h3 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a></h3><ul><li>VS Code plugin for prettier/prettier. 让VSCode支持用<a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">prettier</a>优化JavaScript / TypeScript / CSS文件.</li></ul><h3 id="Beautify"><a href="#Beautify" class="headerlink" title="Beautify"></a><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify" target="_blank" rel="noopener">Beautify</a></h3><ul><li>Beautify javascript, JSON, CSS, Sass, and HTML in Visual Studio Code. 美化js、json、css、sass和html格式。按F1，命令输入Beautify即可执行美化。</li></ul><h3 id="Bracket-Pair-Colorizer"><a href="#Bracket-Pair-Colorizer" class="headerlink" title="Bracket Pair Colorizer"></a><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorizer</a></h3><ul><li>A customizable extension for colorizing matching brackets. 帮你把配对的小括号、中括号、大括号用不同的颜色区分，方便查看。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164232.png" alt="Bracket Pair Colorizer"></p><h3 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a><a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="noopener">Debugger for Chrome</a></h3><ul><li>Debug your JavaScript code in the Chrome browser, or any other target that supports the Chrome Debugger protocol. 在谷歌浏览器中调试js代码，并且可以在VSCode中打断点。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo22fy3o0jg21400p0npl.gif" alt="Debugger for Chrome"></p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a><a href="https://marketplace.visualstudio.com/items?itemName=eg2.vscode-npm-script" target="_blank" rel="noopener">npm</a></h3><ul><li>npm support for VS Code. 装了它可以让VSCode有NPM的一些功能，还能提示你package.json中哪些依赖模块没有安装。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164318.png" alt="npm1"><br><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164330.png" alt="npm2"></p><h3 id="npm-Intellisense"><a href="#npm-Intellisense" class="headerlink" title="npm Intellisense"></a><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense" target="_blank" rel="noopener">npm Intellisense</a></h3><ul><li>Visual Studio Code plugin that autocompletes npm modules in import statements. 装了它，在js中引入npm包的时候可以帮你自动补全。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo22ll6pcfg20pv07t7hn.gif" alt="npm Intellisense"></p><h3 id="Full-HTML-tags-including-HTML5-Snippets"><a href="#Full-HTML-tags-including-HTML5-Snippets" class="headerlink" title="Full HTML tags including HTML5 Snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets" target="_blank" rel="noopener">Full HTML tags including HTML5 Snippets</a></h3><ul><li>Full HTML tags including HTML5 Snippets. 让VSCode支持HTML5的代码片段.</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo22u7cx1sg20ny0gydqz.gif" alt="Full HTML tags including HTML5 Snippets"></p><h3 id="JavaScript-ES6-code-snippets"><a href="#JavaScript-ES6-code-snippets" class="headerlink" title="JavaScript (ES6) code snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets" target="_blank" rel="noopener">JavaScript (ES6) code snippets</a></h3><ul><li>Code snippets for JavaScript in ES6 syntax. 让VSCode支持ES6语法的代码片段。</li></ul><h3 id="jQuery-Code-Snippets"><a href="#jQuery-Code-Snippets" class="headerlink" title="jQuery Code Snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.jquerysnippets" target="_blank" rel="noopener">jQuery Code Snippets</a></h3><ul><li>Over 130 jQuery Code Snippets for JavaScript code. jQuery代码块插件.</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164438.png" alt="jQuery Code Snippets"></p><h3 id="Document-This"><a href="#Document-This" class="headerlink" title="Document This"></a><a href="https://marketplace.visualstudio.com/items?itemName=joelday.docthis" target="_blank" rel="noopener">Document This</a></h3><ul><li>Automatically generates detailed JSDoc comments in TypeScript and JavaScript files. ts或者js中自动生成详细的注释。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo23b5kf4lg213i0ty0xq.gif" alt="Document This"></p><h3 id="language-stylus"><a href="#language-stylus" class="headerlink" title="language-stylus"></a><a href="https://marketplace.visualstudio.com/items?itemName=sysoev.language-stylus" target="_blank" rel="noopener">language-stylus</a></h3><ul><li>Stylus language support. 让VSCode支持Stylus语法。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo22wos68yg20ns0egakp.gif" alt="language-stylus"></p><h3 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a><a href="https://marketplace.visualstudio.com/items?itemName=robinbentley.sass-indented" target="_blank" rel="noopener">Sass</a></h3><ul><li>Indented Sass syntax highlighting, autocomplete &amp; snippets. 让VSCode支持Sass语法、高亮、自动补全、代码片段。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164535.png" alt="Sass"></p><h3 id="SVG-Viewer"><a href="#SVG-Viewer" class="headerlink" title="SVG Viewer"></a><a href="https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer" target="_blank" rel="noopener">SVG Viewer</a></h3><ul><li>SVG Viewer for Visual Studio Code. 让VSCode可以预览SVG格式的图片。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo23tsyucjg20nd0ib0we.gif" alt="SVG Viewer"></p><h3 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open in browser"></a><a href="https://marketplace.visualstudio.com/items?itemName=techer.open-in-browser" target="_blank" rel="noopener">open in browser</a></h3><ul><li>This allows you to open the current file in your default browser or application. 帮你用默认浏览器打开当前的文件。VSCode本身没有这个功能，想看单个页面，安了这个就很方便。</li></ul><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></h3><ul><li>Integrates ESLint into VS Code. 让VSCode支持ESLint编码规范，此规范略显严格，刚开始可能很不习惯，久了会对代码编写规范养成有很大帮助。我目前的项目都是开启了ESLint规范检查的。</li></ul><h3 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a></h3><ul><li>Vue tooling for VS Code. VSCode的Vue工具插件，官方推荐，值得信赖。<strong><a href="https://vuejs.github.io/vetur" target="_blank" rel="noopener">文档传送门</a></strong>。</li></ul><h3 id="Vue-2-Snippets"><a href="#Vue-2-Snippets" class="headerlink" title="Vue 2 Snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets" target="_blank" rel="noopener">Vue 2 Snippets</a></h3><ul><li>A Vue.js 2 Extension. 这个插件基于最新的 Vue 官方语法高亮文件添加了Syntax Highlight，并且依据 Vue 2 的 API 添加了Code Snippets。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164616.png" alt="Vue 2 Snippets1"><br><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164634.png" alt="Vue 2 Snippet2"></p><h2 id="通用工具插件扩展"><a href="#通用工具插件扩展" class="headerlink" title="通用工具插件扩展"></a>通用工具插件扩展</h2><h3 id="Settings-Sync"><a href="#Settings-Sync" class="headerlink" title="Settings Sync"></a><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">Settings Sync</a></h3><ul><li>Synchronize Settings, Snippets, Themes, File Icons, Launch, Keybindings, Workspaces and Extensions Across Multiple Machines Using GitHub Gist. 重点推荐Settings Sync，这个插件的功能是帮你同步VsCode插件的，只要你上传了你的插件配置，家里和办公区电脑，重装系统后，都能同步，而且轻松就能分享你安装的插件给他人。可以理解为你VSCode的插件和设置，都帮你云备份了，你随时可以更新、下载，是通过GitHub的Personal Access Token备份的，如果没有的话，是时候申请一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>号了。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo221x1em6g20hs0991l0.gif" alt="Settings Sync"></p><h3 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a></h3><ul><li>Run C, C++, Java, JS, PHP, Python, Perl, Ruby, Go, Lua, Groovy, PowerShell, CMD, BASH, F#, C#, VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml, R, AppleScript, Elixir, VB.NET, Clojure, Haxe, Objective-C, Rust, Racket, AutoHotkey, AutoIt, Kotlin, Dart, Pascal, Haskell, Nim, D. 可以在VSCode运行以上语法的代码片段，可以说很强大。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo24dej24gg21fo0xwwjh.gif" alt="Code Runner"></p><h3 id="Git-History"><a href="#Git-History" class="headerlink" title="Git History"></a><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" target="_blank" rel="noopener">Git History</a></h3><ul><li>View git log, file history, compare branches or commits. 可以让你看到git源代码的日志，包括文件编辑历史，和以前分支对比等。推荐。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo24gfubm0g20zk0m87wk.gif" alt="Git History"></p><h3 id="Git-Lens-—-git-blame-annotations-code-lens-and-more"><a href="#Git-Lens-—-git-blame-annotations-code-lens-and-more" class="headerlink" title="Git Lens — git blame annotations, code lens, and more"></a><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank" rel="noopener">Git Lens — git blame annotations, code lens, and more</a></h3><ul><li>Supercharge Visual Studio Code’s Git capabilities — Visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore the history of a file or branch, gain valuable insights via powerful comparison commands, and so much more. 加强VSCode的Git功能，通过git clone命令下来的项目，都在每一个文件每一行中看见原创作者提交时的日志，包括你修改时提交的日志，并且有对比功能。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo24jbjm9jg20k70gonpe.gif" alt="Git Lens — git blame annotations, code lens, and more"></p><h3 id="XML-Tools"><a href="#XML-Tools" class="headerlink" title="XML Tools"></a><a href="https://marketplace.visualstudio.com/items?itemName=DotJoshJohnson.xml" target="_blank" rel="noopener">XML Tools</a></h3><ul><li>XML Formatting, XQuery, and XPath Tools for Visual Studio Code. 让VSCode支持XML格式化、预览、检查等功能。</li></ul><h3 id="Markdown-All-in-One"><a href="#Markdown-All-in-One" class="headerlink" title="Markdown All in One"></a><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one" target="_blank" rel="noopener">Markdown All in One</a></h3><p>All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more). 加强VSCode markdown文件的编辑能力，增加markdown语法快捷键，优化list编辑，格式化等。</p><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo24sf5b2tg20k50a5mxv.gif" alt="Markdown All in One1"><br><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo24skl69sg20k50a5gmh.gif" alt="Markdown All in One2"></p><h3 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced" target="_blank" rel="noopener">Markdown Preview Enhanced</a></h3><ul><li>Markdown Preview Enhanced ported to vscode. 增强VSCode的Markdown文件预览功能.</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220164950.png" alt="Markdown Preview Enhanced"></p><h2 id="其他语言支持插件扩展"><a href="#其他语言支持插件扩展" class="headerlink" title="其他语言支持插件扩展"></a>其他语言支持插件扩展</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++</a></h3><ul><li>C/C++ IntelliSense, debugging, and code browsing. 可以让VSCode智能提示、调试、运行C++代码。</li></ul><h3 id="C-C-Snippets"><a href="#C-C-Snippets" class="headerlink" title="C/C++ Snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=hars.CppSnippets" target="_blank" rel="noopener">C/C++ Snippets</a></h3><ul><li>Code snippets for C/C++. 让VSCode可以输入C/C++代码片段。</li></ul><h3 id="C"><a href="#C" class="headerlink" title="C#"></a><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp" target="_blank" rel="noopener">C#</a></h3><ul><li>C# for Visual Studio Code (powered by OmniSharp). 官方出品的VSCode C#插件。</li></ul><h3 id="C-FixFormat"><a href="#C-FixFormat" class="headerlink" title="C# FixFormat"></a><a href="https://marketplace.visualstudio.com/items?itemName=Leopotam.csharpfixformat" target="_blank" rel="noopener">C# FixFormat</a></h3><ul><li>Fix format of usings / indents / braces / empty lines. 增强VSCode对C#文件格式化能力。</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python" target="_blank" rel="noopener">Python</a></h3><ul><li>Linting, Debugging (multi-threaded, remote), Intellisense, code formatting, refactoring, unit tests, snippets, and more. VSCode Python插件，支持python语法检查、调试（多线程调试、远程调试）、智能提示、格式化py文件、重构、单元测试、python代码片段等。</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a><a href="https://marketplace.visualstudio.com/items?itemName=lukehoban.Go" target="_blank" rel="noopener">Go</a></h3><ul><li>Rich Go language support for Visual Studio Code. 加强VSCode对GO语言的支持。</li></ul><p><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/7a5fa15ely1fo254iqr4pg20qw0gz4qq.gif" alt="Go"></p><h3 id="Language-Support-for-Java-TM-by-Red-Hat"><a href="#Language-Support-for-Java-TM-by-Red-Hat" class="headerlink" title="Language Support for Java(TM) by Red Hat"></a><a href="https://marketplace.visualstudio.com/items?itemName=redhat.java" target="_blank" rel="noopener">Language Support for Java(TM) by Red Hat</a></h3><ul><li>Language Support for Java(TM) for Visual Studio Code provided by Red Hat. 让VSCode支持Java语法。</li></ul><p>以上就是我的全部分享，插图来源于<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">VSCode官网</a>。如果大家有发现什么好用的插件，欢迎分享出来。</p><p>最后附上我Settings Sync共享的公共ID：</p><ul><li>Gist ID：d4256477db4b00ee69749e1bb69cb5f0</li></ul><p>同步的时候，GitHub Token填自己的，然后输这个Gist ID即可。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017小结</title>
      <link href="/2018/01/2017-summary/"/>
      <url>/2018/01/2017-summary/</url>
      
        <content type="html"><![CDATA[<p>记得高中时候，班主任就经常教育我们不要忘了总结。今天算是把这个好习惯捡起来了。</p><a id="more"></a><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><p>工作上其实挺忙，学习的时间被自己压缩了很多，好在年终总结时也得到了领导肯定与认可。工作上，还是有几点还是值得自己肯定，极大的提升自己能力。</p><ul><li>公司用户大会展台显示程序开发。</li><li>公司展厅触屏演示程序开发。</li><li>客户端产品个人重心从插件客户端偏向无插件客户端。</li></ul><p>用户大会开发第一次接触VR开发，而且参会人数高达5000人，记得自己的展示程序在展会开始前一天才做好。公司展厅触屏演示程序还是工作以来第一次编写WPF程序，好好地学习了一番，学习理解运用WPF的MVVM概念，帮助我后面学习VUE的MVVM概念奠定了基础。工作上学习了公司基于Cesium二次开发的客户端WebGL产品，其友好性可以说激发了我对前端学习的兴趣。</p><p>学习上。前面提到，培养了前端学习兴趣之后，我发现前端很open，开放资源，开放的项目很多，自学很方便，于是我开启了我心酸自学前端之路。</p><p>先后学习了前端JavaScript、CSS基础和公司前端产品，能保证自己工作岗位支持要求。然后逐步学习了jQuery、bootstrap、easyUI等前端js/css框架。大约2017年中的时候，又学习到了js模块话的思想，先后学习了AMD、CMD的一些规范。直到后来我发现有更新的东西等着我，我开始接触了es6的一些规范，学习了nodejs，学习了反人类工具webpack，以及它的一切皆模块思想。到这个时候，才基本上跟上了前端的发展步伐。于是我抓紧时间学习了webpack，那时候正是webpack1.0出来的时候，还记得后来webpack升级2.0了，规则改了很多，我的项目不能用了，采坑填坑了很久，才把项目升级成功。那时候还写了一篇博文：<a href="http://blog.csdn.net/supermapsupport/article/details/56290480" target="_blank" rel="noopener">webpack引入SuperMap iClient3D 8C for Plugin</a>。紧接着又了解到前端Vue框架，了解之后觉得是真的不错，开启了Vue学习之路，期间学习了es6语法，eslint代码编写规范，并且引入到自己项目中。</p><p>总结一下，前端学习上目前学习nodejs、express、npm平台、vue全家桶、travis-ci，开始混迹于Github，并且发了第一个PR，而且得到了采纳。<br><img src="https://zouyaoji-1300719013.cos.ap-chengdu.myqcloud.com/zouyaoji.top/20191220171558.png" alt="https://github.com/Dafrok/vue-baidu-map/pull/285">当时还是很激动的。</p><p>刚申请了阿里云服务器，并且注册了域名，加油吧~</p><h2 id="期望、目标"><a href="#期望、目标" class="headerlink" title="期望、目标"></a>期望、目标</h2><p>写下2018年自己计划学习的东西：</p><ul><li>更加深入学习Vue全家桶</li><li>做一个开源项目</li><li>封装vue-sm-cesium组件</li><li>学习Cordova</li><li>学习Electron</li><li>github robot</li><li>python</li></ul><p>希望我的2018年能够继续有所收获！</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
